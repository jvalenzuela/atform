"""
This is the top-level module in the pdf subpackage, assembling content
generated by section submodules for processing by ReportLab Platypus,
and applying non-sectional items such as headers and footers.
"""

import os

from reportlab.platypus import (
    Frame,
    IndexingFlowable,
    Paragraph,
    SimpleDocTemplate,
)

from .. import id as id_
from . import (
    approval,
    environ,
    equip,
    layout,
    notes,
    objective,
    precondition,
    procedure,
    refs,
    title,
)
from .. import state
from .textstyle import stylesheet


class BuildError(Exception):
    """Exception chained from a PDF generation failure."""


def build(test, cache, root, folder_depth, version):
    """Builds a PDF document for a given test instance."""
    path = build_path(test.id, root, folder_depth)
    try:
        doc = TestDocument(test, cache, path, version)
    except Exception as e:
        tid = id_.to_string(test.id)
        raise BuildError(f"Failed to build PDF for {tid} {test.title}: {e}") from e

    # Return data to be written to the cache file.
    return test.id, {
        "page count": doc.page_count.last_page,
    }


def build_path(tid, root, depth):
    """Constructs a path where a test's output PDF will be written.

    The path will consist of the root, followed by a folder per
    section number limited to depth, e.g., <root>/<x>/<y> for an ID x.y.z
    and depth 2. The final number in an ID is not translated to a folder.
    """
    folders = [root]

    # Append a folder for each section level.
    for i, section_id in enumerate(tid[:depth]):

        # Include the section number and title if the section has a title.
        try:
            section = state.section_titles[tid[: i + 1]]
            section_folder = f"{section_id} {section}"

        # Use only the section number if the section has no title.
        except KeyError:
            section_folder = str(section_id)

        folders.append(section_folder)

    return os.path.join(*folders)


class TestDocument:
    """This class creates a PDF for a single Test instance."""

    def __init__(self, test, cache, path, version):
        self.test = test
        self.version = version

        # The full name is the combination of the test's numeric
        # identifier and title.
        self.full_name = " ".join((id_.to_string(test.id), test.title))

        self.bottom_margin = layout.BOTTOM_MARGIN

        if state.copyright_:
            self.copyright = Paragraph(
                state.copyright_,
                stylesheet["CopyrightNotice"],
            )

            # Compute the vertical height needed to hold the copyright
            # notice when wrapped to within the document body width.
            self.copyright_height = (
                self.copyright.wrap(layout.BODY_WIDTH, 0)[1]
                # Additional space for descenders on the bottom line.
                + stylesheet["CopyrightNotice"].fontSize * 0.25
            )

            # Enlarge the bottom margin to accommodate the copyright notice.
            self.bottom_margin += self.copyright_height

        doc = self._get_doc(path)
        try:
            cached_page_count = cache["page count"]
        except TypeError:
            cached_page_count = 1
        self.page_count = PageCount(doc, cached_page_count)
        body = [self.page_count]
        body.extend(self._build_body(test))
        doc.multiBuild(
            body,
            maxPasses=1,  # Page count takes up to two, zero-based count.
            onFirstPage=self.on_first_page,
            onLaterPages=self.on_later_pages,
        )

    def _get_doc(self, path):
        """Creates the document template."""
        pdfname = self.full_name + ".pdf"
        os.makedirs(path, exist_ok=True)
        filename = os.path.join(path, pdfname)
        return SimpleDocTemplate(
            filename,
            pagesize=layout.PAGE_SIZE,
            leftMargin=layout.LEFT_MARGIN,
            rightMargin=layout.RIGHT_MARGIN,
            topMargin=layout.TOP_MARGIN,
            bottomMargin=self.bottom_margin,
        )

    def on_first_page(self, canvas, doc):
        """Document template callback for the first page."""
        self._on_every_page(canvas, doc)

    def on_later_pages(self, canvas, doc):
        """Document template callback for all pages after the first."""
        self._on_every_page(canvas, doc)
        self._header(canvas, doc)

    def _on_every_page(self, canvas, doc):
        """Draws common content placed on every page."""
        if self.version == "draft":
            self._draftmark(canvas, doc)

        self._footer(canvas, doc)

    def _header(self, canvas, doc):
        """Draws the page header."""
        self._set_canvas_text_style(canvas, "Header")
        baseline = doc.pagesize[1] - layout.TOP_MARGIN
        canvas.drawString(
            layout.LEFT_MARGIN,
            baseline,
            self.full_name,
        )

    def _footer(self, canvas, doc):
        """Draws the page footer."""
        baseline = self.bottom_margin

        # The copyright notice is placed in a dedicated frame so the text
        # can be wrapped as necessary.
        if state.copyright_:
            baseline -= self.copyright_height
            frame = Frame(
                layout.LEFT_MARGIN,
                baseline,
                layout.BODY_WIDTH,
                self.copyright_height,
                leftPadding=0,
                rightPadding=0,
                topPadding=0,
                bottomPadding=0,
            )
            frame.addFromList([self.copyright], canvas)

        self._set_canvas_text_style(canvas, "Footer")

        # Offset text relative to the font size.
        baseline -= stylesheet["Footer"].fontSize * 1.2

        pages = f"Page {doc.page} of {self.page_count.last_page}"
        canvas.drawCentredString(doc.pagesize[0] / 2, baseline, pages)

        # Add version information if available.
        if self.version and (self.version != "draft"):
            x = doc.pagesize[0] - layout.RIGHT_MARGIN
            version_text = f"Document Version: {self.version}"
            canvas.drawRightString(x, baseline, version_text)

    def _set_canvas_text_style(self, canvas, style):
        """Sets the current canvas font to a given style."""
        style = stylesheet[style]
        canvas.setFont(style.fontName, style.fontSize)

    def _build_body(self, test):
        """
        Assembles the list of flowables representing all content other
        than the header and footer.
        """
        flowables = [
            title.make_title(test),
            objective.make_objective(test.objective),
            refs.make_references(test.references),
            environ.make_environment(test.fields),
            equip.make_equipment(test.equipment),
            precondition.make_preconditions(test.preconditions),
            procedure.make_procedure(test.procedure),
            notes.make_notes(),
            approval.make_approval(),
        ]

        return [f for f in flowables if f]

    def _draftmark(self, canvas, doc):
        """Creates a draft watermark."""
        canvas.saveState()
        self._set_canvas_text_style(canvas, "Draftmark")

        # Translate origin to center of page.
        canvas.translate(doc.pagesize[0] / 2, doc.pagesize[1] / 2)

        canvas.rotate(45)
        canvas.setFillColor(layout.DRAFTMARK_COLOR)

        # Offset y coordinate by half the font size because the text
        # is anchored at its baseline, not the midpoint.
        y = stylesheet["Draftmark"].fontSize / -2

        canvas.drawCentredString(0, y, "DRAFT")
        canvas.restoreState()


class PageCount(IndexingFlowable):
    """Total page count accumulator.

    This object captures the total number of pages. It is implemented as an
    IndexingFlowable so document template multiBuild() can handle runnning
    multiple build passes to determine the total number of pages.
    """

    def __init__(self, doc, page_count):
        super().__init__()
        self.doc = doc
        self.last_page = page_count

    def isSatisfied(self):
        """Document template multiBuild() hook to enable another build pass."""
        # The build is complete if the page number equals the cached last
        # page number.
        if self.last_page == self.doc.page:
            return True

        # Update cached last page and build again.
        self.last_page = self.doc.page
        return False

    def draw(self):
        """This flowable doesn't draw anything."""
