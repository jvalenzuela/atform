Organization
============

Sectioning
----------

By default, |project_name| will automatically number tests with increasing integers,
a simple approach that may be insufficient. Most projects will need
additional organizational levels to separate related test procedures into
sections, and |project_name| can be configured to use multiple integer fields for
numbering tests, e.g., 5.1 or 1.8.9. Any quantity of fields can be used,
although practical values are between two and four. The only stipulation
regarding numbering is all test procedures must use the same format,
i.e., *every* test will be numbered with the same quantity of fields.

When using two or more numbering fields, |project_name| refers to each field as a
level, with the first, or highest level, as level zero, increasing up to
the number of configured levels minus one. For example, configuring
three levels, tests will be numbered *x.y.z*; where *x* is level zero, *y* is
level one, and *z* is level two.

The following example shows the two commands for organizing tests
into sections:
:py:func:`atform.set_id_depth` and
:py:func:`atform.section`:

.. literalinclude:: examples/section.py


Skipping Tests
--------------

Having tests automatically numbered is generally helpful, alleviating the
task of manually enumerating tests and sections. However, there are
some circumstances where the author must intervene. The most common
cases are reserving a range of numbers for future use, or removing a
defunct test without affecting later ones. The following example illustrates
some different methods of skipping numbers:

.. literalinclude:: examples/skip.py


Source Files
------------

Another tactic for organizing test procedures is to split them into separate
scripts. Dividing large constructs into smaller components, each within their
own file is common in many domains, including documentation. This approach
makes it easier to locate content and for multiple authors to work on tests
simultaneously. Separating tests into multiple scripts, however, does not
affect the output; tests are numbered in the order they are encountered
regardless of how many source files are involved.

Organizing tests into multiple scripts utilizes Python's :code:`import` keyword.
The examples so far use :code:`import atform` to load |project_name|;
separate scripts, each containing their own set of tests, e.g., one script
per section, can be imported in a similar fashion. The recommended way to
do this is to arrange scripts heirarchically, with one script at the top-level
containing the setup and output areas, and the actual test content
imported from one or more lower-level scripts. The example below shows
a top-level script that imports content from two, separate files:

.. literalinclude:: examples/main.py

Next are the scripts imported from the main script, illustrating how
content can be distributed into the lower-level scripts:

.. literalinclude:: examples/button.py

.. literalinclude:: examples/switch.py

When generating PDF output for tests in multiple files, execute the top-level
script only, which will automatically incorporate any imported scripts.
All tests in the example above would be generated by running
:command:`python main.py`.
